/**
 * Common knowledges in This Code:
 * 1. lc/LC = local clustering, gm/GM = global merging, 
 * 	  gs/GS = global splitting, CF = cluster feature
 * 2. original RR = RR list generated by feature extraction, 
 *    RR = RR generated by combine ECG data and original RR
 * 3. the output of Global splitting is wrote to the OUTPUT_DIR, 
 *    while all the output of other step are wrote to the INTERMEDIATE_OUTPUT_DIR
 * 4. In Hadoop, Considering the fact that the output of mapper would be quite large, so the 
 *    iterator in the reduce could iterate the whole data once.    
 */
package org.yanglin.mr.lab.ecg;

import java.io.EOFException;
import java.io.IOException;
import java.net.URI;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.Map.Entry;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataInputStream;
import org.apache.hadoop.fs.FSDataOutputStream;
import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IOUtils;
import org.apache.hadoop.io.Text;
import org.mortbay.jetty.EofException;

public class CommonUtility
{
	public static String		ATTR_SCHEME						= "yanglin.shceme";

	public static final String	ATTR_RR_DIR						= "yanglin.ecg.rr.dir";

	public static final String	ATTR_ECG_DATA_DIR				= "yanglin.ecg.data.dir";

	public static final String	ATTR_INTERMEDIATE_OUTPUT_DIR	= "yanglin.intermediateoutput.dir";

	public static final String	ATTR_OUTPUT_DIR					= "yanglin.output.dir";

	public static final String	ATTR_STANDARD_DIR				= "yanglin.standard.dir";

	public static final String	ATTR_KMMR_CENTER_PATH			= "yanglin.kmmr.centerPath";
	
	public static final String	ATTR_KMMR_WORK_DIR  		    = "yanglin.kmmr.workDir";
	
	public static final String	ATTR_KMMR_COUNTER_GROUP 	    = "yanglin.kmmr.counterGroup";
	
	public static final String	ATTR_KMMR_SID			 	    = "yanglin.kmmr.sID";
	
	public static final String	ATTR_KMMR_K			 	    	= "yanglin.kmmr.k";
	
	public static final String  ATTR_KMMR_WORK_DIR_DEP_DIR		= "yanglin.kmmr.workDir.depDir";
	
	public static final String  ATTR_WORK_ID					= "yanglin.workID";
	
	public static final String  ATTR_EV_RR_DIR					= "yanglin.ev.rrDir";
	
	public static final String  ATTR_EV_CF_DIR					= "yanglin.ev.cfDir";
	
	public static final String	COUNTER_CONVERGE				= "converged";
	
	public static final String	PREFIX_ATTR_MERGING_PLAN		= "yanglin.gm.plan.";

	public static final String	FILE_NAME_STANDARD_PR			= "standard_PR";

	public static final String	FILE_NAME_STANDARD_QRS			= "standard_QRS";

	public static final String	FILE_NAME_STANDARD_STE			= "standard_STE";

	public static final String	OUTPUT_LC_RR					= "lc/RR/";

	public static final String	OUTPUT_LC_CF					= "lc/CF/";

	public static final String	OUTPUT_GM_RR					= "gm/RR/";

	public static final String	OUTPUT_GM_CF					= "gm/CF/";

	public static final String	OUTPUT_EV						= "ev/";

	public static final String	OUTPUT_GS_RR					= "RR/";

	public static final String	OUTPUT_GS_CF					= "CF/";
	
	public static final String	OUTPUT_GS_SPLIT_TMP				= "gs/splitTmp/";
	
	public static final String	OUTPUT_GS_CENTER				= "centers";

	public static final String	PREFIX_TYPE_ORI_RR				= "RRCE";

	public static final String	PREFIX_TYPE_CF					= "CF";

	public static final String	PREFIX_TYPE_RR					= "RR";

	public static final String	PREFIX_STEP_LC					= "LC";

	public static final String	PREFIX_STEP_GM					= "GM";

	public static final String	PREFIX_STEP_GS					= "GS";

	public static final String	COMMON_SEPARATOR				= "-";

	public static final int		CLUSTER_NUM_LOCAL_CLUSTERING	= 4;

	public static final int		MAX_ITERATION_LS				= 8;

	public static final int		MAX_ITERATION_GS				= 8;

	public static final int		ARG_NUM							= 6;

	public static final int		DATA_PREFIX_LEN					= 6;

	public static final double	MAX_CLUSTER_CONN				= 1.0d;

	public static final double	RATIO_PR_QRS					= 2.0d;							// TODO:
																									// imprecise

	public static final double	RATIO_STE_QRS					= 3.0d;							// TODO:
																									// more
																									// imprecise

	public static final double	CONVERGE_ERROR					= 0.2d;

	public static final double	WEIGHT_RR_DIS_PR				= 0.15d;

	public static final double	WEIGHT_RR_DIS_QRS				= 0.5d;

	public static final double	WEIGHT_RR_DIS_STE				= 0.35d;
	
	public static final double  MAX_CLUSTER_DISTORTION			= 0.4d;

	/**
	 * Get a string of current time
	 * 
	 * @param format
	 *            format string like yyyy-MM-dd HH:mm:ss
	 * @return
	 */
	static public String getCurrentTimeString(String format)
	{
		SimpleDateFormat formatter = new SimpleDateFormat(format);
		Date curDate = new Date(System.currentTimeMillis());// 获取当前时间
		return new String(formatter.format(curDate));
	}

	/**
	 * Find the name of corresponding RR file according to the given name of
	 * data file
	 * 
	 * @param dataFileName
	 * @return
	 */
	static public String getOriRRFileName(String dataFileName)
	{
		int codeIndex = dataFileName.toString().lastIndexOf('/') + 1
				+ "EcgData".length();
		int codeLen = 6;

		String rrFileName = new String(CommonUtility.PREFIX_TYPE_ORI_RR
				+ dataFileName.toString().substring(codeIndex,
						codeIndex + codeLen) + ".DAT");

		return rrFileName;
	}

	static public String getCFFileName(String rrFileName)
	{
		String cfFileName = CommonUtility.PREFIX_TYPE_CF;
		int start = rrFileName.indexOf(CommonUtility.COMMON_SEPARATOR);
		cfFileName += rrFileName.substring(start);

		return cfFileName;
	}

	static public String getEcgID(String strDataFileName)
	{
		int end = strDataFileName.lastIndexOf("_");
		int start = end - CommonUtility.DATA_PREFIX_LEN;
		String strEcgID = new String(strDataFileName.substring(start, end));
		return strEcgID;
	}

	static public void printConfiguration(Configuration conf)
	{
		System.out.println("--configuration-----");
		for (Entry<String, String> entry : conf)
		{
			System.out.printf("%s=%s\n", entry.getKey(), entry.getValue());
		}
		System.out.println("--------------------");
	}

	static public void deleteHDFSFile(String filePath) throws IOException
	{
		Configuration conf = new Configuration();
		FileSystem fs = FileSystem.get(URI.create(filePath), conf);
		fs.delete(new Path(filePath), true);

	}

	static public void CreateHDFSDir(String strDirPath) throws IOException
	{
		Configuration conf = new Configuration();
		FileSystem fs = FileSystem.get(URI.create(strDirPath), conf);
		if (!fs.exists(new Path(strDirPath)))
		{
			fs.mkdirs(new Path(strDirPath));
		}

	}

	/**
	 * calculate the cluster feature(medoid, longRadius, avgRadius) of a
	 * cluster, complexity: O(n^2)
	 * 
	 * @param cluster
	 * @return
	 */
	static public ClusterFeatureWritable calculateMedoid(
			ArrayList<RRIntervalWritable> cluster)
	{
		System.out.println("--Start calculateMedoid()--");
		long startTime = System.currentTimeMillis();

		RRIntervalWritable medoid = null;
		RRIntervalWritable tmpMedoid = null;
		double longRadius = 0.0d;
		double smallestTotalDistance = Double.MAX_VALUE;

		for (int i = 0; i < cluster.size(); ++i)
		{
			tmpMedoid = cluster.get(i);

			double tmpTotalDis = 0.0d;
			double tmpLongRadius = 0.0d;
			for (int j = 0; j < cluster.size(); ++j)
			{
				if (j == i)
				{
					continue;
				}

				double d = SimilarityMeasurement.calDTWDistance(
						tmpMedoid.qrs.getData(), cluster.get(i).qrs.getData());
				if (d > tmpLongRadius)
				{
					tmpLongRadius = d;
				}

				tmpTotalDis += d;
			}

			if (tmpTotalDis < smallestTotalDistance)
			{
				smallestTotalDistance = tmpTotalDis;

				medoid = tmpMedoid;
				longRadius = tmpLongRadius;
			}
		}

		ClusterFeatureWritable cf = new ClusterFeatureWritable();
		cf.center = medoid;
		cf.longRadius = longRadius;
		cf.totalDis = smallestTotalDistance;

		long endTime = System.currentTimeMillis();

		System.out.println("Function: calculateMedoid() with size:"
				+ cluster.size() + ",cost time: " + (endTime - startTime)
				+ " ms.");

		return cf;
	}

	/**
	 * Read Cluster Feature from file.
	 * 
	 * Note: each file is supposed to contain one cluster feature only.
	 * 
	 * @param strPath
	 *            the file or dir which contains the cluster feature
	 * @return a array list of cluster features
	 * @throws IOException
	 */
	public static ArrayList<ClusterFeatureWritable> readCFfromFile(
			String strPath) throws IOException
	{
		FSDataInputStream in = null;
		ArrayList<ClusterFeatureWritable> cfArray = new ArrayList<ClusterFeatureWritable>();
		Configuration conf = new Configuration();
		FileSystem fs = FileSystem.get(URI.create(strPath), conf);
		FileStatus[] statList = fs.listStatus(new Path(strPath));
		if (null == statList)
		{
			return cfArray;
		}

		for (int i = 0; i < statList.length; ++i)
		{
			in = fs.open(statList[i].getPath());
			ClusterFeatureWritable tmpCF = new ClusterFeatureWritable();
			tmpCF.readFields(in);
			if(tmpCF.rrFileName.toString().length() == 0)
			{
				String strTmpPath = statList[i].getPath().toString();
				String strtmpFileName = strTmpPath.substring(strTmpPath.lastIndexOf("/")+1);
				String strTmpRRName = CommonUtility.PREFIX_TYPE_RR 
						+  strtmpFileName.substring(strtmpFileName.indexOf(CommonUtility.COMMON_SEPARATOR));
				tmpCF.rrFileName = new Text(strTmpRRName);
			}
			
			
			cfArray.add(tmpCF);
			IOUtils.closeStream(in);
		}

		return cfArray;
	}

	/**
	 * Write cluster feature to file
	 * 
	 * NOTE: each file is supposed to contain one cluster feature only.
	 * 
	 * @param cfArray
	 *            Array of cluster feature
	 * @param strDir
	 *            dst dir
	 * @param strFileNamePrefix
	 *            dataFileID
	 * @throws IOException
	 */
	public static void writeCF2File(ClusterFeatureWritable[] cfArray,
			String strDir, String strFileNamePrefix) throws IOException
	{
		FSDataOutputStream out = null;

		Configuration conf = new Configuration();
		FileSystem fs = FileSystem.get(URI.create(strDir), conf);

		int cfCount = cfArray.length;
		for (int i = 0; i < cfCount; ++i)
		{
			if (0 == cfArray[i].pointNum) // do not write to file if it is a
											// empty cluster
			{
				System.out
						.println("Empty cluster, which will not be wrote into file");
				continue;
			}

			String strCFName = strFileNamePrefix
					+ ((cfCount == 1) ? ""
							: (CommonUtility.COMMON_SEPARATOR + i));
			String strCFPath = strDir + strCFName;

			out = fs.create(new Path(strCFPath));
			cfArray[i].write(out);
			out.flush();
			out.close();
		}
	}

	public static int[] readStandard(String strPath) throws IOException
	{
		int[] standard = null;

		Configuration conf = new Configuration();
		FileSystem fs = FileSystem.get(URI.create(strPath), conf);
		FSDataInputStream in = fs.open(new Path(strPath));

		int len = (int) (fs.getLength(new Path(strPath)) / 2);
		standard = new int[len];

		for (int i = 0; i < len; ++i)
		{
			int ch1 = in.read();
			int ch2 = in.read();
			int tmp = (short) ((ch2 << 8) + (ch1 << 0));
			standard[i] = tmp;
		}

		in.close();

		return standard;

	}

	public static void arrayAdd(int[] base, int[] incre)
	{
		if (incre.length != base.length)
		{
			return;
		}

		for (int i = 0; i < base.length; ++i)
		{
			base[i] += incre[i];
		}
	}

	public static void arrayDivide(int[] base, int num)
	{
		for (int i = 0; i < base.length; ++i)
		{
			int tmp = base[i] / num;
			base[i] = tmp;
		}
	}
	
	public static void move2FinalOutput(String srcPath, String desDir) throws IOException
	{
		FileSystem fs = FileSystem.get(URI.create(srcPath), new Configuration() );
		if(fs.isFile(new Path(srcPath)) )
		{
			String strFileName = srcPath.substring(srcPath.lastIndexOf("/") );
			
			
			fs.rename(new Path(srcPath), 
					new Path(desDir + strFileName));
		}
		else
		{
			FileStatus[] statList = fs.listStatus(new Path(srcPath));
			if (null == statList)
			{
				System.out.println("WARN: No file to move from " + srcPath);
				return;
			}

			// move recursively
			for (int i = 0; i < statList.length; ++i)
			{
				if(!statList[i].isDir() ) // only move files
				{
					String strResultPath = statList[i].getPath().toString();
					String strFileName = strResultPath.substring(strResultPath.lastIndexOf("/") + 1);
					
					fs.rename(new Path(strResultPath), 
							new Path(desDir + strFileName));
				}
				
			}
			
		}
		
	}
	
	public static void arraySet(int[] array, int value)
	{
		for(int i = 0; i < array.length; ++i)
		{
			array[i] = value;
		}
	}
	
	public static void arrayFindMinMax(int[] target, int[] max, int[] min) throws IOException
	{
		if(max.length != target.length || min.length != target.length)
		{
			throw new IOException("Invalid length");
		}
		
		int len = target.length;
		int tmpDimData = 0;
		for (int i = 0; i < len; ++i)
		{
			tmpDimData = target[i];
			if (tmpDimData > max[i])
			{
				max[i] = tmpDimData;
			}

			if (tmpDimData < min[i])
			{
				min[i] = tmpDimData;
			}
		}
	}

}
